// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: infra.proto

package proto

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type Reply struct {
	Successful           bool     `protobuf:"varint,1,opt,name=successful,proto3" json:"successful,omitempty"`
	ErrorMessage         string   `protobuf:"bytes,2,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Reply) Reset()         { *m = Reply{} }
func (m *Reply) String() string { return proto.CompactTextString(m) }
func (*Reply) ProtoMessage()    {}
func (*Reply) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd059abf8f713b80, []int{0}
}
func (m *Reply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Reply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Reply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Reply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Reply.Merge(m, src)
}
func (m *Reply) XXX_Size() int {
	return m.Size()
}
func (m *Reply) XXX_DiscardUnknown() {
	xxx_messageInfo_Reply.DiscardUnknown(m)
}

var xxx_messageInfo_Reply proto.InternalMessageInfo

func (m *Reply) GetSuccessful() bool {
	if m != nil {
		return m.Successful
	}
	return false
}

func (m *Reply) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

type NatEndpoint struct {
	Ipv4Addr             string   `protobuf:"bytes,1,opt,name=ipv4_addr,json=ipv4Addr,proto3" json:"ipv4_addr,omitempty"`
	Port                 uint32   `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NatEndpoint) Reset()         { *m = NatEndpoint{} }
func (m *NatEndpoint) String() string { return proto.CompactTextString(m) }
func (*NatEndpoint) ProtoMessage()    {}
func (*NatEndpoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd059abf8f713b80, []int{1}
}
func (m *NatEndpoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NatEndpoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NatEndpoint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NatEndpoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NatEndpoint.Merge(m, src)
}
func (m *NatEndpoint) XXX_Size() int {
	return m.Size()
}
func (m *NatEndpoint) XXX_DiscardUnknown() {
	xxx_messageInfo_NatEndpoint.DiscardUnknown(m)
}

var xxx_messageInfo_NatEndpoint proto.InternalMessageInfo

func (m *NatEndpoint) GetIpv4Addr() string {
	if m != nil {
		return m.Ipv4Addr
	}
	return ""
}

func (m *NatEndpoint) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

type NatEndpointTuple struct {
	DstEp                *NatEndpoint `protobuf:"bytes,1,opt,name=dst_ep,json=dstEp,proto3" json:"dst_ep,omitempty"`
	SrcEp                *NatEndpoint `protobuf:"bytes,2,opt,name=src_ep,json=srcEp,proto3" json:"src_ep,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *NatEndpointTuple) Reset()         { *m = NatEndpointTuple{} }
func (m *NatEndpointTuple) String() string { return proto.CompactTextString(m) }
func (*NatEndpointTuple) ProtoMessage()    {}
func (*NatEndpointTuple) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd059abf8f713b80, []int{2}
}
func (m *NatEndpointTuple) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NatEndpointTuple) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NatEndpointTuple.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NatEndpointTuple) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NatEndpointTuple.Merge(m, src)
}
func (m *NatEndpointTuple) XXX_Size() int {
	return m.Size()
}
func (m *NatEndpointTuple) XXX_DiscardUnknown() {
	xxx_messageInfo_NatEndpointTuple.DiscardUnknown(m)
}

var xxx_messageInfo_NatEndpointTuple proto.InternalMessageInfo

func (m *NatEndpointTuple) GetDstEp() *NatEndpoint {
	if m != nil {
		return m.DstEp
	}
	return nil
}

func (m *NatEndpointTuple) GetSrcEp() *NatEndpoint {
	if m != nil {
		return m.SrcEp
	}
	return nil
}

type NatTranslation struct {
	Endpoint             *NatEndpoint        `protobuf:"bytes,2,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	Proto                string              `protobuf:"bytes,3,opt,name=proto,proto3" json:"proto,omitempty"`
	IsRealIp             bool                `protobuf:"varint,4,opt,name=is_real_ip,json=isRealIp,proto3" json:"is_real_ip,omitempty"`
	Backends             []*NatEndpointTuple `protobuf:"bytes,6,rep,name=backends,proto3" json:"backends,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *NatTranslation) Reset()         { *m = NatTranslation{} }
func (m *NatTranslation) String() string { return proto.CompactTextString(m) }
func (*NatTranslation) ProtoMessage()    {}
func (*NatTranslation) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd059abf8f713b80, []int{3}
}
func (m *NatTranslation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NatTranslation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NatTranslation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NatTranslation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NatTranslation.Merge(m, src)
}
func (m *NatTranslation) XXX_Size() int {
	return m.Size()
}
func (m *NatTranslation) XXX_DiscardUnknown() {
	xxx_messageInfo_NatTranslation.DiscardUnknown(m)
}

var xxx_messageInfo_NatTranslation proto.InternalMessageInfo

func (m *NatTranslation) GetEndpoint() *NatEndpoint {
	if m != nil {
		return m.Endpoint
	}
	return nil
}

func (m *NatTranslation) GetProto() string {
	if m != nil {
		return m.Proto
	}
	return ""
}

func (m *NatTranslation) GetIsRealIp() bool {
	if m != nil {
		return m.IsRealIp
	}
	return false
}

func (m *NatTranslation) GetBackends() []*NatEndpointTuple {
	if m != nil {
		return m.Backends
	}
	return nil
}

type SetSnatAddressRequest struct {
	SnatIpv4             string   `protobuf:"bytes,1,opt,name=snat_ipv4,json=snatIpv4,proto3" json:"snat_ipv4,omitempty"`
	SnatIpv6             string   `protobuf:"bytes,2,opt,name=snat_ipv6,json=snatIpv6,proto3" json:"snat_ipv6,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SetSnatAddressRequest) Reset()         { *m = SetSnatAddressRequest{} }
func (m *SetSnatAddressRequest) String() string { return proto.CompactTextString(m) }
func (*SetSnatAddressRequest) ProtoMessage()    {}
func (*SetSnatAddressRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd059abf8f713b80, []int{4}
}
func (m *SetSnatAddressRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetSnatAddressRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetSnatAddressRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetSnatAddressRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetSnatAddressRequest.Merge(m, src)
}
func (m *SetSnatAddressRequest) XXX_Size() int {
	return m.Size()
}
func (m *SetSnatAddressRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SetSnatAddressRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SetSnatAddressRequest proto.InternalMessageInfo

func (m *SetSnatAddressRequest) GetSnatIpv4() string {
	if m != nil {
		return m.SnatIpv4
	}
	return ""
}

func (m *SetSnatAddressRequest) GetSnatIpv6() string {
	if m != nil {
		return m.SnatIpv6
	}
	return ""
}

type AddDelSnatPrefixRequest struct {
	IsAdd                bool     `protobuf:"varint,1,opt,name=is_add,json=isAdd,proto3" json:"is_add,omitempty"`
	Prefix               string   `protobuf:"bytes,2,opt,name=prefix,proto3" json:"prefix,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AddDelSnatPrefixRequest) Reset()         { *m = AddDelSnatPrefixRequest{} }
func (m *AddDelSnatPrefixRequest) String() string { return proto.CompactTextString(m) }
func (*AddDelSnatPrefixRequest) ProtoMessage()    {}
func (*AddDelSnatPrefixRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd059abf8f713b80, []int{5}
}
func (m *AddDelSnatPrefixRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddDelSnatPrefixRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddDelSnatPrefixRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddDelSnatPrefixRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddDelSnatPrefixRequest.Merge(m, src)
}
func (m *AddDelSnatPrefixRequest) XXX_Size() int {
	return m.Size()
}
func (m *AddDelSnatPrefixRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AddDelSnatPrefixRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AddDelSnatPrefixRequest proto.InternalMessageInfo

func (m *AddDelSnatPrefixRequest) GetIsAdd() bool {
	if m != nil {
		return m.IsAdd
	}
	return false
}

func (m *AddDelSnatPrefixRequest) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

type CreateNetworkRequest struct {
	ContainerIps             []*IPConfiguration `protobuf:"bytes,1,rep,name=container_ips,json=containerIps,proto3" json:"container_ips,omitempty"`
	DesiredHostInterfaceName string             `protobuf:"bytes,2,opt,name=desired_host_interface_name,json=desiredHostInterfaceName,proto3" json:"desired_host_interface_name,omitempty"`
	HostIfName               string             `protobuf:"bytes,3,opt,name=host_if_name,json=hostIfName,proto3" json:"host_if_name,omitempty"`
	MacAddr                  string             `protobuf:"bytes,4,opt,name=mac_addr,json=macAddr,proto3" json:"mac_addr,omitempty"`
	XXX_NoUnkeyedLiteral     struct{}           `json:"-"`
	XXX_unrecognized         []byte             `json:"-"`
	XXX_sizecache            int32              `json:"-"`
}

func (m *CreateNetworkRequest) Reset()         { *m = CreateNetworkRequest{} }
func (m *CreateNetworkRequest) String() string { return proto.CompactTextString(m) }
func (*CreateNetworkRequest) ProtoMessage()    {}
func (*CreateNetworkRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd059abf8f713b80, []int{6}
}
func (m *CreateNetworkRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateNetworkRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateNetworkRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateNetworkRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateNetworkRequest.Merge(m, src)
}
func (m *CreateNetworkRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateNetworkRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateNetworkRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateNetworkRequest proto.InternalMessageInfo

func (m *CreateNetworkRequest) GetContainerIps() []*IPConfiguration {
	if m != nil {
		return m.ContainerIps
	}
	return nil
}

func (m *CreateNetworkRequest) GetDesiredHostInterfaceName() string {
	if m != nil {
		return m.DesiredHostInterfaceName
	}
	return ""
}

func (m *CreateNetworkRequest) GetHostIfName() string {
	if m != nil {
		return m.HostIfName
	}
	return ""
}

func (m *CreateNetworkRequest) GetMacAddr() string {
	if m != nil {
		return m.MacAddr
	}
	return ""
}

type DeleteNetworkRequest struct {
	InterfaceName        string   `protobuf:"bytes,1,opt,name=interface_name,json=interfaceName,proto3" json:"interface_name,omitempty"`
	HostIfName           string   `protobuf:"bytes,2,opt,name=host_if_name,json=hostIfName,proto3" json:"host_if_name,omitempty"`
	MacAddr              string   `protobuf:"bytes,3,opt,name=mac_addr,json=macAddr,proto3" json:"mac_addr,omitempty"`
	Ipv4Addr             string   `protobuf:"bytes,4,opt,name=ipv4_addr,json=ipv4Addr,proto3" json:"ipv4_addr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteNetworkRequest) Reset()         { *m = DeleteNetworkRequest{} }
func (m *DeleteNetworkRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteNetworkRequest) ProtoMessage()    {}
func (*DeleteNetworkRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd059abf8f713b80, []int{7}
}
func (m *DeleteNetworkRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteNetworkRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteNetworkRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteNetworkRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteNetworkRequest.Merge(m, src)
}
func (m *DeleteNetworkRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteNetworkRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteNetworkRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteNetworkRequest proto.InternalMessageInfo

func (m *DeleteNetworkRequest) GetInterfaceName() string {
	if m != nil {
		return m.InterfaceName
	}
	return ""
}

func (m *DeleteNetworkRequest) GetHostIfName() string {
	if m != nil {
		return m.HostIfName
	}
	return ""
}

func (m *DeleteNetworkRequest) GetMacAddr() string {
	if m != nil {
		return m.MacAddr
	}
	return ""
}

func (m *DeleteNetworkRequest) GetIpv4Addr() string {
	if m != nil {
		return m.Ipv4Addr
	}
	return ""
}

type SetupHostInterfaceRequest struct {
	IfName               string   `protobuf:"bytes,1,opt,name=if_name,json=ifName,proto3" json:"if_name,omitempty"`
	Ipv4Addr             string   `protobuf:"bytes,2,opt,name=ipv4_addr,json=ipv4Addr,proto3" json:"ipv4_addr,omitempty"`
	MacAddr              string   `protobuf:"bytes,3,opt,name=mac_addr,json=macAddr,proto3" json:"mac_addr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SetupHostInterfaceRequest) Reset()         { *m = SetupHostInterfaceRequest{} }
func (m *SetupHostInterfaceRequest) String() string { return proto.CompactTextString(m) }
func (*SetupHostInterfaceRequest) ProtoMessage()    {}
func (*SetupHostInterfaceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd059abf8f713b80, []int{8}
}
func (m *SetupHostInterfaceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetupHostInterfaceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetupHostInterfaceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetupHostInterfaceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetupHostInterfaceRequest.Merge(m, src)
}
func (m *SetupHostInterfaceRequest) XXX_Size() int {
	return m.Size()
}
func (m *SetupHostInterfaceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SetupHostInterfaceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SetupHostInterfaceRequest proto.InternalMessageInfo

func (m *SetupHostInterfaceRequest) GetIfName() string {
	if m != nil {
		return m.IfName
	}
	return ""
}

func (m *SetupHostInterfaceRequest) GetIpv4Addr() string {
	if m != nil {
		return m.Ipv4Addr
	}
	return ""
}

func (m *SetupHostInterfaceRequest) GetMacAddr() string {
	if m != nil {
		return m.MacAddr
	}
	return ""
}

type IPConfiguration struct {
	Address              string   `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Gateway              string   `protobuf:"bytes,2,opt,name=gateway,proto3" json:"gateway,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IPConfiguration) Reset()         { *m = IPConfiguration{} }
func (m *IPConfiguration) String() string { return proto.CompactTextString(m) }
func (*IPConfiguration) ProtoMessage()    {}
func (*IPConfiguration) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd059abf8f713b80, []int{9}
}
func (m *IPConfiguration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IPConfiguration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IPConfiguration.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IPConfiguration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPConfiguration.Merge(m, src)
}
func (m *IPConfiguration) XXX_Size() int {
	return m.Size()
}
func (m *IPConfiguration) XXX_DiscardUnknown() {
	xxx_messageInfo_IPConfiguration.DiscardUnknown(m)
}

var xxx_messageInfo_IPConfiguration proto.InternalMessageInfo

func (m *IPConfiguration) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *IPConfiguration) GetGateway() string {
	if m != nil {
		return m.Gateway
	}
	return ""
}

type InfraAddReply struct {
	Successful           bool     `protobuf:"varint,1,opt,name=successful,proto3" json:"successful,omitempty"`
	ErrorMessage         string   `protobuf:"bytes,2,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	HostInterfaceName    string   `protobuf:"bytes,3,opt,name=host_interface_name,json=hostInterfaceName,proto3" json:"host_interface_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InfraAddReply) Reset()         { *m = InfraAddReply{} }
func (m *InfraAddReply) String() string { return proto.CompactTextString(m) }
func (*InfraAddReply) ProtoMessage()    {}
func (*InfraAddReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd059abf8f713b80, []int{10}
}
func (m *InfraAddReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InfraAddReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InfraAddReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InfraAddReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InfraAddReply.Merge(m, src)
}
func (m *InfraAddReply) XXX_Size() int {
	return m.Size()
}
func (m *InfraAddReply) XXX_DiscardUnknown() {
	xxx_messageInfo_InfraAddReply.DiscardUnknown(m)
}

var xxx_messageInfo_InfraAddReply proto.InternalMessageInfo

func (m *InfraAddReply) GetSuccessful() bool {
	if m != nil {
		return m.Successful
	}
	return false
}

func (m *InfraAddReply) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

func (m *InfraAddReply) GetHostInterfaceName() string {
	if m != nil {
		return m.HostInterfaceName
	}
	return ""
}

func init() {
	proto.RegisterType((*Reply)(nil), "infra.Reply")
	proto.RegisterType((*NatEndpoint)(nil), "infra.NatEndpoint")
	proto.RegisterType((*NatEndpointTuple)(nil), "infra.NatEndpointTuple")
	proto.RegisterType((*NatTranslation)(nil), "infra.NatTranslation")
	proto.RegisterType((*SetSnatAddressRequest)(nil), "infra.SetSnatAddressRequest")
	proto.RegisterType((*AddDelSnatPrefixRequest)(nil), "infra.AddDelSnatPrefixRequest")
	proto.RegisterType((*CreateNetworkRequest)(nil), "infra.CreateNetworkRequest")
	proto.RegisterType((*DeleteNetworkRequest)(nil), "infra.DeleteNetworkRequest")
	proto.RegisterType((*SetupHostInterfaceRequest)(nil), "infra.SetupHostInterfaceRequest")
	proto.RegisterType((*IPConfiguration)(nil), "infra.IPConfiguration")
	proto.RegisterType((*InfraAddReply)(nil), "infra.InfraAddReply")
}

func init() { proto.RegisterFile("infra.proto", fileDescriptor_cd059abf8f713b80) }

var fileDescriptor_cd059abf8f713b80 = []byte{
	// 1112 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0x5d, 0x4f, 0x1b, 0x47,
	0x17, 0xce, 0xf2, 0x61, 0xcc, 0x31, 0x06, 0x32, 0x18, 0x6c, 0x3e, 0x5e, 0xcb, 0xda, 0x57, 0x95,
	0xe8, 0x8d, 0xa5, 0x90, 0x28, 0x52, 0x9a, 0x26, 0x91, 0xc1, 0x34, 0xb1, 0x04, 0x88, 0x2e, 0xb4,
	0xa9, 0x7a, 0x63, 0x0d, 0xbb, 0xc7, 0x30, 0x62, 0xbd, 0xbb, 0x9d, 0x19, 0x93, 0x70, 0xdf, 0xeb,
	0xde, 0xb6, 0x7f, 0x21, 0xff, 0xa4, 0x77, 0xed, 0x55, 0xaf, 0x2b, 0xfa, 0x47, 0xaa, 0x9d, 0x99,
	0x35, 0x5e, 0xaf, 0x17, 0x88, 0xd4, 0x2b, 0x98, 0xf3, 0xf1, 0x9c, 0xe7, 0x3c, 0x73, 0xe6, 0x78,
	0xa1, 0xc4, 0x82, 0x1e, 0xa7, 0xcd, 0x88, 0x87, 0x32, 0x24, 0xb3, 0xea, 0xb0, 0x41, 0x7a, 0xe8,
	0xb3, 0x8f, 0x67, 0xd4, 0xbd, 0xc4, 0xc0, 0xd3, 0x2e, 0xfb, 0x00, 0x66, 0x1d, 0x8c, 0xfc, 0x6b,
	0x52, 0x07, 0x10, 0x03, 0xd7, 0x45, 0x21, 0x7a, 0x03, 0xbf, 0x66, 0x35, 0xac, 0xed, 0xa2, 0x33,
	0x62, 0x21, 0xff, 0x87, 0x32, 0x72, 0x1e, 0xf2, 0x6e, 0x1f, 0x85, 0xa0, 0xe7, 0x58, 0x9b, 0x6a,
	0x58, 0xdb, 0xf3, 0xce, 0x82, 0x32, 0x1e, 0x6a, 0x9b, 0xfd, 0x1a, 0x4a, 0x47, 0x54, 0xee, 0x07,
	0x5e, 0x14, 0xb2, 0x40, 0x92, 0x4d, 0x98, 0x67, 0xd1, 0xd5, 0xb3, 0x2e, 0xf5, 0x3c, 0xae, 0x20,
	0xe7, 0x9d, 0x62, 0x6c, 0x68, 0x79, 0x1e, 0x27, 0x04, 0x66, 0xa2, 0x90, 0x4b, 0x85, 0x53, 0x76,
	0xd4, 0xff, 0xf6, 0x05, 0x2c, 0x8f, 0xe4, 0x9f, 0x0e, 0x22, 0x1f, 0xc9, 0x97, 0x50, 0xf0, 0x84,
	0xec, 0x62, 0xa4, 0x10, 0x4a, 0x3b, 0xa4, 0xa9, 0x5b, 0x1b, 0x09, 0x74, 0x66, 0x3d, 0x21, 0xf7,
	0xa3, 0x38, 0x54, 0x70, 0x37, 0x0e, 0x9d, 0xca, 0x0f, 0x15, 0xdc, 0xdd, 0x8f, 0xec, 0x4f, 0x16,
	0x2c, 0x1e, 0x51, 0x79, 0xca, 0x69, 0x20, 0x7c, 0x2a, 0x59, 0x18, 0x90, 0x26, 0x14, 0xd1, 0x44,
	0xdd, 0x91, 0x3f, 0x8c, 0x21, 0x15, 0x98, 0x55, 0x1a, 0xd6, 0xa6, 0x55, 0x67, 0xfa, 0x40, 0xb6,
	0x00, 0x98, 0xe8, 0x72, 0xa4, 0x7e, 0x97, 0x45, 0xb5, 0x19, 0xa5, 0x63, 0x91, 0x09, 0x07, 0xa9,
	0xdf, 0x89, 0xc8, 0x53, 0x28, 0x1a, 0xfd, 0x45, 0xad, 0xd0, 0x98, 0xde, 0x2e, 0xed, 0x54, 0xb3,
	0x35, 0x54, 0xdf, 0xce, 0x30, 0xd0, 0xfe, 0x16, 0x56, 0x4f, 0x50, 0x9e, 0x04, 0x54, 0xc6, 0xc2,
	0xa1, 0x10, 0x0e, 0xfe, 0x34, 0x40, 0xa1, 0xf4, 0x15, 0x01, 0x95, 0xdd, 0x58, 0xd3, 0x44, 0xdf,
	0xd8, 0xd0, 0x89, 0xae, 0x9e, 0x8d, 0x3a, 0x9f, 0x9b, 0xcb, 0x4a, 0x9c, 0xcf, 0xed, 0x77, 0x50,
	0x6d, 0x79, 0x5e, 0x1b, 0xfd, 0x18, 0xf5, 0x98, 0x63, 0x8f, 0x7d, 0x4c, 0x40, 0x57, 0xa1, 0xc0,
	0x44, 0x7c, 0x65, 0x66, 0x08, 0x66, 0x99, 0x68, 0x79, 0x1e, 0x59, 0x83, 0x42, 0xa4, 0xe2, 0x0c,
	0x96, 0x39, 0xd9, 0x7f, 0x58, 0x50, 0xd9, 0xe3, 0x48, 0x25, 0x1e, 0xa1, 0xfc, 0x10, 0xf2, 0xcb,
	0x04, 0xe7, 0x25, 0x94, 0xdd, 0x30, 0x90, 0x94, 0x05, 0xc8, 0xbb, 0x2c, 0x12, 0x35, 0x4b, 0xf5,
	0xbb, 0x66, 0xfa, 0xed, 0x1c, 0xef, 0x85, 0x41, 0x8f, 0x9d, 0x0f, 0xb8, 0x52, 0xdf, 0x59, 0x18,
	0x06, 0x77, 0x22, 0x41, 0x5e, 0xc1, 0xa6, 0x87, 0x82, 0x71, 0xf4, 0xba, 0x17, 0xa1, 0x90, 0x5d,
	0x16, 0x48, 0xe4, 0x3d, 0xea, 0x62, 0x37, 0xa0, 0xfd, 0x64, 0xf6, 0x6a, 0x26, 0xe4, 0x5d, 0x28,
	0x64, 0x27, 0x09, 0x38, 0xa2, 0x7d, 0x24, 0x0d, 0x58, 0xd0, 0x69, 0x3d, 0x1d, 0xaf, 0x6f, 0x08,
	0x62, 0x5b, 0xa7, 0xa7, 0x22, 0xd6, 0xa1, 0xd8, 0xa7, 0xae, 0x9e, 0xcc, 0x19, 0xe5, 0x9d, 0xeb,
	0x53, 0x37, 0xd6, 0xd7, 0xfe, 0xd5, 0x82, 0x4a, 0x1b, 0x7d, 0xcc, 0x74, 0xf4, 0x05, 0x2c, 0x8e,
	0xf1, 0xd0, 0x9a, 0x97, 0xd9, 0x9d, 0xc5, 0xa7, 0xee, 0x2c, 0x3e, 0x9d, 0x2a, 0x9e, 0x7e, 0x32,
	0x33, 0xe9, 0x27, 0x63, 0xfb, 0xb0, 0x7e, 0x82, 0x72, 0x10, 0xa5, 0x1a, 0x4e, 0xd8, 0x55, 0x61,
	0x2e, 0xa9, 0xa8, 0x69, 0x15, 0x98, 0xae, 0x96, 0x82, 0x9c, 0x1a, 0x7b, 0x85, 0xf9, 0x54, 0xec,
	0x7d, 0x58, 0x1a, 0xbb, 0x24, 0x52, 0x83, 0x39, 0xaa, 0x47, 0xd0, 0xd4, 0x48, 0x8e, 0xb1, 0xe7,
	0x9c, 0x4a, 0xfc, 0x40, 0xaf, 0x4d, 0x89, 0xe4, 0x68, 0xff, 0x6c, 0x41, 0xb9, 0x13, 0x5f, 0x79,
	0xcb, 0xf3, 0xfe, 0xbb, 0x55, 0x43, 0x9a, 0xb0, 0x32, 0x69, 0x32, 0x74, 0x0f, 0x8f, 0x2f, 0xc6,
	0x47, 0x62, 0xe7, 0x2f, 0x0b, 0x8a, 0x8a, 0xc6, 0x5e, 0xc0, 0x48, 0x1b, 0xca, 0xa9, 0x99, 0x25,
	0x9b, 0x66, 0x2a, 0x27, 0x4d, 0xf2, 0x46, 0x25, 0x19, 0xd9, 0xd1, 0x2e, 0xec, 0x47, 0xe4, 0x6b,
	0x28, 0xa7, 0xe6, 0x64, 0x88, 0x32, 0x69, 0x7a, 0x36, 0x16, 0x8c, 0x33, 0xc9, 0xfe, 0x06, 0x48,
	0xf6, 0x32, 0x49, 0xc3, 0x44, 0xe5, 0xde, 0xf3, 0x38, 0xce, 0xce, 0x2f, 0x53, 0x46, 0xdf, 0x13,
	0xe4, 0x57, 0xcc, 0x45, 0x41, 0xbe, 0x82, 0xc7, 0xe9, 0xd5, 0x16, 0xbf, 0xdf, 0xd5, 0xdb, 0x3d,
	0x33, 0xe2, 0xc9, 0xb0, 0x7a, 0x0d, 0x8b, 0xe9, 0x5d, 0x43, 0xb6, 0x6e, 0x19, 0x65, 0x57, 0x50,
	0x26, 0x7f, 0x17, 0x96, 0xc7, 0x17, 0x0b, 0xa9, 0x9b, 0x98, 0x9c, 0x8d, 0x93, 0xc1, 0x78, 0x05,
	0x95, 0x34, 0x4b, 0xad, 0xe7, 0x03, 0x5b, 0xd8, 0xf9, 0xb4, 0x00, 0x25, 0x25, 0xc8, 0x71, 0xe8,
	0x33, 0xf7, 0x9a, 0xbc, 0x01, 0xd2, 0x72, 0x25, 0xbb, 0x42, 0x7d, 0xfe, 0x2e, 0xf2, 0xa8, 0x44,
	0xb2, 0xde, 0x54, 0xbf, 0x86, 0xcd, 0xac, 0x2b, 0xc3, 0x67, 0x0c, 0xc0, 0xc1, 0x7e, 0x78, 0x35,
	0x19, 0x40, 0xbb, 0x32, 0x00, 0x4f, 0xa0, 0xa4, 0xa1, 0x3b, 0xc7, 0x27, 0x28, 0x09, 0x31, 0x99,
	0xea, 0x94, 0x53, 0xf3, 0x25, 0x2c, 0x8f, 0xa4, 0xb4, 0xd1, 0x97, 0x94, 0x54, 0x47, 0xf3, 0x94,
	0x29, 0x27, 0xf9, 0x09, 0x94, 0x34, 0x93, 0x09, 0xf5, 0x72, 0x28, 0xb6, 0x60, 0x45, 0x83, 0x99,
	0x76, 0x78, 0xd8, 0x63, 0x3e, 0x92, 0x8d, 0x74, 0x93, 0xda, 0x9a, 0x53, 0xb5, 0x05, 0x2b, 0x1a,
	0xfc, 0x01, 0x10, 0x39, 0x2c, 0xde, 0x00, 0xd1, 0xe0, 0xf1, 0xe4, 0x0f, 0x3f, 0x23, 0x12, 0xa5,
	0x47, 0x8d, 0xf9, 0x57, 0xa5, 0xa1, 0xef, 0x05, 0xc8, 0x61, 0xd0, 0x4e, 0x74, 0x38, 0x08, 0x5d,
	0xea, 0x0f, 0x11, 0xfe, 0x67, 0x10, 0xde, 0x87, 0xfc, 0xd2, 0x0f, 0xa9, 0x77, 0x0f, 0x8d, 0x76,
	0x22, 0xc5, 0xc3, 0x50, 0x1e, 0xa2, 0xc6, 0x21, 0x4a, 0xda, 0xa6, 0x92, 0xa6, 0x9a, 0x89, 0x8d,
	0x1e, 0xcd, 0x9d, 0x83, 0x94, 0x1a, 0x77, 0x02, 0xe4, 0x30, 0xd8, 0x83, 0x8a, 0x86, 0x36, 0xbb,
	0xa5, 0xe5, 0xba, 0xe1, 0x20, 0xfe, 0xb0, 0x33, 0x10, 0x69, 0x73, 0x0e, 0x8b, 0x3d, 0xa8, 0x68,
	0xf8, 0x07, 0x81, 0xe4, 0x30, 0x79, 0x01, 0x4b, 0x1a, 0x3e, 0x5e, 0xe6, 0x22, 0x8a, 0x57, 0xe5,
	0x9a, 0xc9, 0x1f, 0x5a, 0x72, 0xea, 0xbf, 0x80, 0x25, 0x0d, 0x7a, 0x47, 0xea, 0x7d, 0x0f, 0xd7,
	0x09, 0x07, 0x12, 0x87, 0x0f, 0x49, 0x9d, 0xee, 0x7b, 0x7b, 0x13, 0x52, 0x72, 0xaa, 0x1c, 0xc2,
	0xba, 0x06, 0xfb, 0xfe, 0x87, 0x83, 0xd6, 0xd1, 0xe9, 0x20, 0x08, 0xf0, 0x76, 0x66, 0x1a, 0x06,
	0x60, 0x82, 0x2f, 0x87, 0xc1, 0x21, 0xac, 0xeb, 0x42, 0x9f, 0x09, 0x97, 0xc3, 0xae, 0x03, 0x55,
	0x5d, 0xe8, 0x3d, 0xe3, 0x78, 0x3e, 0xa0, 0x7c, 0x38, 0xb6, 0xa4, 0x9e, 0xcc, 0xf3, 0xb8, 0x27,
	0x87, 0x59, 0x07, 0xaa, 0xba, 0xc8, 0x67, 0x40, 0xe5, 0xb0, 0xda, 0x87, 0x55, 0x5d, 0xe4, 0xad,
	0x1f, 0x9e, 0x51, 0x7f, 0xf7, 0xad, 0xf9, 0x52, 0x21, 0x5b, 0x06, 0x68, 0xcc, 0x3e, 0x99, 0xd1,
	0x6e, 0xf5, 0xf7, 0x9b, 0xba, 0xf5, 0xe7, 0x4d, 0xdd, 0xfa, 0xfb, 0xa6, 0x6e, 0xfd, 0xf6, 0x4f,
	0xfd, 0xd1, 0x8f, 0xfa, 0x33, 0xfe, 0xac, 0xa0, 0xfe, 0x3c, 0xfd, 0x37, 0x00, 0x00, 0xff, 0xff,
	0x2a, 0xaf, 0xc4, 0x95, 0x48, 0x0d, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// InfraCniClient is the client API for InfraCni service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type InfraCniClient interface {
	CreateNetwork(ctx context.Context, in *CreateNetworkRequest, opts ...grpc.CallOption) (*InfraAddReply, error)
	DeleteNetwork(ctx context.Context, in *DeleteNetworkRequest, opts ...grpc.CallOption) (*Reply, error)
	SetupHostInterface(ctx context.Context, in *SetupHostInterfaceRequest, opts ...grpc.CallOption) (*Reply, error)
}

type infraCniClient struct {
	cc *grpc.ClientConn
}

func NewInfraCniClient(cc *grpc.ClientConn) InfraCniClient {
	return &infraCniClient{cc}
}

func (c *infraCniClient) CreateNetwork(ctx context.Context, in *CreateNetworkRequest, opts ...grpc.CallOption) (*InfraAddReply, error) {
	out := new(InfraAddReply)
	err := c.cc.Invoke(ctx, "/infra.InfraCni/CreateNetwork", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infraCniClient) DeleteNetwork(ctx context.Context, in *DeleteNetworkRequest, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := c.cc.Invoke(ctx, "/infra.InfraCni/DeleteNetwork", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infraCniClient) SetupHostInterface(ctx context.Context, in *SetupHostInterfaceRequest, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := c.cc.Invoke(ctx, "/infra.InfraCni/SetupHostInterface", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InfraCniServer is the server API for InfraCni service.
type InfraCniServer interface {
	CreateNetwork(context.Context, *CreateNetworkRequest) (*InfraAddReply, error)
	DeleteNetwork(context.Context, *DeleteNetworkRequest) (*Reply, error)
	SetupHostInterface(context.Context, *SetupHostInterfaceRequest) (*Reply, error)
}

// UnimplementedInfraCniServer can be embedded to have forward compatible implementations.
type UnimplementedInfraCniServer struct {
}

func (*UnimplementedInfraCniServer) CreateNetwork(ctx context.Context, req *CreateNetworkRequest) (*InfraAddReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateNetwork not implemented")
}
func (*UnimplementedInfraCniServer) DeleteNetwork(ctx context.Context, req *DeleteNetworkRequest) (*Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteNetwork not implemented")
}
func (*UnimplementedInfraCniServer) SetupHostInterface(ctx context.Context, req *SetupHostInterfaceRequest) (*Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetupHostInterface not implemented")
}

func RegisterInfraCniServer(s *grpc.Server, srv InfraCniServer) {
	s.RegisterService(&_InfraCni_serviceDesc, srv)
}

func _InfraCni_CreateNetwork_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateNetworkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfraCniServer).CreateNetwork(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/infra.InfraCni/CreateNetwork",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfraCniServer).CreateNetwork(ctx, req.(*CreateNetworkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InfraCni_DeleteNetwork_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteNetworkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfraCniServer).DeleteNetwork(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/infra.InfraCni/DeleteNetwork",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfraCniServer).DeleteNetwork(ctx, req.(*DeleteNetworkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InfraCni_SetupHostInterface_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetupHostInterfaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfraCniServer).SetupHostInterface(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/infra.InfraCni/SetupHostInterface",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfraCniServer).SetupHostInterface(ctx, req.(*SetupHostInterfaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _InfraCni_serviceDesc = grpc.ServiceDesc{
	ServiceName: "infra.InfraCni",
	HandlerType: (*InfraCniServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateNetwork",
			Handler:    _InfraCni_CreateNetwork_Handler,
		},
		{
			MethodName: "DeleteNetwork",
			Handler:    _InfraCni_DeleteNetwork_Handler,
		},
		{
			MethodName: "SetupHostInterface",
			Handler:    _InfraCni_SetupHostInterface_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "infra.proto",
}

// InfraServicesClient is the client API for InfraServices service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type InfraServicesClient interface {
	NatTranslationAdd(ctx context.Context, in *NatTranslation, opts ...grpc.CallOption) (*Reply, error)
	SetSnatAddress(ctx context.Context, in *SetSnatAddressRequest, opts ...grpc.CallOption) (*Reply, error)
	AddDelSnatPrefix(ctx context.Context, in *AddDelSnatPrefixRequest, opts ...grpc.CallOption) (*Reply, error)
	NatTranslationDelete(ctx context.Context, in *NatTranslation, opts ...grpc.CallOption) (*Reply, error)
}

type infraServicesClient struct {
	cc *grpc.ClientConn
}

func NewInfraServicesClient(cc *grpc.ClientConn) InfraServicesClient {
	return &infraServicesClient{cc}
}

func (c *infraServicesClient) NatTranslationAdd(ctx context.Context, in *NatTranslation, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := c.cc.Invoke(ctx, "/infra.InfraServices/NatTranslationAdd", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infraServicesClient) SetSnatAddress(ctx context.Context, in *SetSnatAddressRequest, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := c.cc.Invoke(ctx, "/infra.InfraServices/SetSnatAddress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infraServicesClient) AddDelSnatPrefix(ctx context.Context, in *AddDelSnatPrefixRequest, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := c.cc.Invoke(ctx, "/infra.InfraServices/AddDelSnatPrefix", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infraServicesClient) NatTranslationDelete(ctx context.Context, in *NatTranslation, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := c.cc.Invoke(ctx, "/infra.InfraServices/NatTranslationDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InfraServicesServer is the server API for InfraServices service.
type InfraServicesServer interface {
	NatTranslationAdd(context.Context, *NatTranslation) (*Reply, error)
	SetSnatAddress(context.Context, *SetSnatAddressRequest) (*Reply, error)
	AddDelSnatPrefix(context.Context, *AddDelSnatPrefixRequest) (*Reply, error)
	NatTranslationDelete(context.Context, *NatTranslation) (*Reply, error)
}

// UnimplementedInfraServicesServer can be embedded to have forward compatible implementations.
type UnimplementedInfraServicesServer struct {
}

func (*UnimplementedInfraServicesServer) NatTranslationAdd(ctx context.Context, req *NatTranslation) (*Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NatTranslationAdd not implemented")
}
func (*UnimplementedInfraServicesServer) SetSnatAddress(ctx context.Context, req *SetSnatAddressRequest) (*Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetSnatAddress not implemented")
}
func (*UnimplementedInfraServicesServer) AddDelSnatPrefix(ctx context.Context, req *AddDelSnatPrefixRequest) (*Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddDelSnatPrefix not implemented")
}
func (*UnimplementedInfraServicesServer) NatTranslationDelete(ctx context.Context, req *NatTranslation) (*Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NatTranslationDelete not implemented")
}

func RegisterInfraServicesServer(s *grpc.Server, srv InfraServicesServer) {
	s.RegisterService(&_InfraServices_serviceDesc, srv)
}

func _InfraServices_NatTranslationAdd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NatTranslation)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfraServicesServer).NatTranslationAdd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/infra.InfraServices/NatTranslationAdd",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfraServicesServer).NatTranslationAdd(ctx, req.(*NatTranslation))
	}
	return interceptor(ctx, in, info, handler)
}

func _InfraServices_SetSnatAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetSnatAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfraServicesServer).SetSnatAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/infra.InfraServices/SetSnatAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfraServicesServer).SetSnatAddress(ctx, req.(*SetSnatAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InfraServices_AddDelSnatPrefix_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddDelSnatPrefixRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfraServicesServer).AddDelSnatPrefix(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/infra.InfraServices/AddDelSnatPrefix",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfraServicesServer).AddDelSnatPrefix(ctx, req.(*AddDelSnatPrefixRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InfraServices_NatTranslationDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NatTranslation)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfraServicesServer).NatTranslationDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/infra.InfraServices/NatTranslationDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfraServicesServer).NatTranslationDelete(ctx, req.(*NatTranslation))
	}
	return interceptor(ctx, in, info, handler)
}

var _InfraServices_serviceDesc = grpc.ServiceDesc{
	ServiceName: "infra.InfraServices",
	HandlerType: (*InfraServicesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "NatTranslationAdd",
			Handler:    _InfraServices_NatTranslationAdd_Handler,
		},
		{
			MethodName: "SetSnatAddress",
			Handler:    _InfraServices_SetSnatAddress_Handler,
		},
		{
			MethodName: "AddDelSnatPrefix",
			Handler:    _InfraServices_AddDelSnatPrefix_Handler,
		},
		{
			MethodName: "NatTranslationDelete",
			Handler:    _InfraServices_NatTranslationDelete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "infra.proto",
}

// InfraPolicyClient is the client API for InfraPolicy service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type InfraPolicyClient interface {
	ActivePolicyUpdate(ctx context.Context, in *ActivePolicyUpdate, opts ...grpc.CallOption) (*Reply, error)
	ActivePolicyRemove(ctx context.Context, in *ActivePolicyRemove, opts ...grpc.CallOption) (*Reply, error)
	UpdateIPSet(ctx context.Context, in *IPSetUpdate, opts ...grpc.CallOption) (*Reply, error)
	UpdateIPSetDelta(ctx context.Context, in *IPSetDeltaUpdate, opts ...grpc.CallOption) (*Reply, error)
	RemoveIPSet(ctx context.Context, in *IPSetRemove, opts ...grpc.CallOption) (*Reply, error)
	UpdateActiveProfile(ctx context.Context, in *ActiveProfileUpdate, opts ...grpc.CallOption) (*Reply, error)
	RemoveActiveProfile(ctx context.Context, in *ActiveProfileRemove, opts ...grpc.CallOption) (*Reply, error)
	UpdateHostEndpoint(ctx context.Context, in *HostEndpointUpdate, opts ...grpc.CallOption) (*Reply, error)
	RemoveHostEndpoint(ctx context.Context, in *HostEndpointRemove, opts ...grpc.CallOption) (*Reply, error)
	UpdateLocalEndpoint(ctx context.Context, in *WorkloadEndpointUpdate, opts ...grpc.CallOption) (*Reply, error)
	RemoveLocalEndpoint(ctx context.Context, in *WorkloadEndpointRemove, opts ...grpc.CallOption) (*Reply, error)
	UpdateHostMetaData(ctx context.Context, in *HostMetadataUpdate, opts ...grpc.CallOption) (*Reply, error)
	RemoveHostMetaData(ctx context.Context, in *HostMetadataRemove, opts ...grpc.CallOption) (*Reply, error)
	UpdateServiceAccount(ctx context.Context, in *ServiceAccountUpdate, opts ...grpc.CallOption) (*Reply, error)
	RemoveServiceAccount(ctx context.Context, in *ServiceAccountRemove, opts ...grpc.CallOption) (*Reply, error)
	UpdateNamespace(ctx context.Context, in *NamespaceUpdate, opts ...grpc.CallOption) (*Reply, error)
	RemoveNamespace(ctx context.Context, in *NamespaceRemove, opts ...grpc.CallOption) (*Reply, error)
	UpdateRoute(ctx context.Context, in *RouteUpdate, opts ...grpc.CallOption) (*Reply, error)
	RemoveRoute(ctx context.Context, in *RouteRemove, opts ...grpc.CallOption) (*Reply, error)
	UpdateVXLANTunnelEndpoint(ctx context.Context, in *VXLANTunnelEndpointUpdate, opts ...grpc.CallOption) (*Reply, error)
	RemoveVXLANTunnelEndpoint(ctx context.Context, in *VXLANTunnelEndpointRemove, opts ...grpc.CallOption) (*Reply, error)
	UpdateWireguardEndpoint(ctx context.Context, in *WireguardEndpointUpdate, opts ...grpc.CallOption) (*Reply, error)
	RemoveWireguardEndpoint(ctx context.Context, in *WireguardEndpointRemove, opts ...grpc.CallOption) (*Reply, error)
	UpdateGlobalBGPConfig(ctx context.Context, in *GlobalBGPConfigUpdate, opts ...grpc.CallOption) (*Reply, error)
}

type infraPolicyClient struct {
	cc *grpc.ClientConn
}

func NewInfraPolicyClient(cc *grpc.ClientConn) InfraPolicyClient {
	return &infraPolicyClient{cc}
}

func (c *infraPolicyClient) ActivePolicyUpdate(ctx context.Context, in *ActivePolicyUpdate, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := c.cc.Invoke(ctx, "/infra.InfraPolicy/ActivePolicyUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infraPolicyClient) ActivePolicyRemove(ctx context.Context, in *ActivePolicyRemove, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := c.cc.Invoke(ctx, "/infra.InfraPolicy/ActivePolicyRemove", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infraPolicyClient) UpdateIPSet(ctx context.Context, in *IPSetUpdate, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := c.cc.Invoke(ctx, "/infra.InfraPolicy/UpdateIPSet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infraPolicyClient) UpdateIPSetDelta(ctx context.Context, in *IPSetDeltaUpdate, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := c.cc.Invoke(ctx, "/infra.InfraPolicy/UpdateIPSetDelta", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infraPolicyClient) RemoveIPSet(ctx context.Context, in *IPSetRemove, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := c.cc.Invoke(ctx, "/infra.InfraPolicy/RemoveIPSet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infraPolicyClient) UpdateActiveProfile(ctx context.Context, in *ActiveProfileUpdate, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := c.cc.Invoke(ctx, "/infra.InfraPolicy/UpdateActiveProfile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infraPolicyClient) RemoveActiveProfile(ctx context.Context, in *ActiveProfileRemove, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := c.cc.Invoke(ctx, "/infra.InfraPolicy/RemoveActiveProfile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infraPolicyClient) UpdateHostEndpoint(ctx context.Context, in *HostEndpointUpdate, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := c.cc.Invoke(ctx, "/infra.InfraPolicy/UpdateHostEndpoint", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infraPolicyClient) RemoveHostEndpoint(ctx context.Context, in *HostEndpointRemove, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := c.cc.Invoke(ctx, "/infra.InfraPolicy/RemoveHostEndpoint", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infraPolicyClient) UpdateLocalEndpoint(ctx context.Context, in *WorkloadEndpointUpdate, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := c.cc.Invoke(ctx, "/infra.InfraPolicy/UpdateLocalEndpoint", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infraPolicyClient) RemoveLocalEndpoint(ctx context.Context, in *WorkloadEndpointRemove, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := c.cc.Invoke(ctx, "/infra.InfraPolicy/RemoveLocalEndpoint", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infraPolicyClient) UpdateHostMetaData(ctx context.Context, in *HostMetadataUpdate, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := c.cc.Invoke(ctx, "/infra.InfraPolicy/UpdateHostMetaData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infraPolicyClient) RemoveHostMetaData(ctx context.Context, in *HostMetadataRemove, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := c.cc.Invoke(ctx, "/infra.InfraPolicy/RemoveHostMetaData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infraPolicyClient) UpdateServiceAccount(ctx context.Context, in *ServiceAccountUpdate, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := c.cc.Invoke(ctx, "/infra.InfraPolicy/UpdateServiceAccount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infraPolicyClient) RemoveServiceAccount(ctx context.Context, in *ServiceAccountRemove, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := c.cc.Invoke(ctx, "/infra.InfraPolicy/RemoveServiceAccount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infraPolicyClient) UpdateNamespace(ctx context.Context, in *NamespaceUpdate, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := c.cc.Invoke(ctx, "/infra.InfraPolicy/UpdateNamespace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infraPolicyClient) RemoveNamespace(ctx context.Context, in *NamespaceRemove, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := c.cc.Invoke(ctx, "/infra.InfraPolicy/RemoveNamespace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infraPolicyClient) UpdateRoute(ctx context.Context, in *RouteUpdate, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := c.cc.Invoke(ctx, "/infra.InfraPolicy/UpdateRoute", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infraPolicyClient) RemoveRoute(ctx context.Context, in *RouteRemove, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := c.cc.Invoke(ctx, "/infra.InfraPolicy/RemoveRoute", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infraPolicyClient) UpdateVXLANTunnelEndpoint(ctx context.Context, in *VXLANTunnelEndpointUpdate, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := c.cc.Invoke(ctx, "/infra.InfraPolicy/UpdateVXLANTunnelEndpoint", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infraPolicyClient) RemoveVXLANTunnelEndpoint(ctx context.Context, in *VXLANTunnelEndpointRemove, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := c.cc.Invoke(ctx, "/infra.InfraPolicy/RemoveVXLANTunnelEndpoint", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infraPolicyClient) UpdateWireguardEndpoint(ctx context.Context, in *WireguardEndpointUpdate, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := c.cc.Invoke(ctx, "/infra.InfraPolicy/UpdateWireguardEndpoint", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infraPolicyClient) RemoveWireguardEndpoint(ctx context.Context, in *WireguardEndpointRemove, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := c.cc.Invoke(ctx, "/infra.InfraPolicy/RemoveWireguardEndpoint", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infraPolicyClient) UpdateGlobalBGPConfig(ctx context.Context, in *GlobalBGPConfigUpdate, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := c.cc.Invoke(ctx, "/infra.InfraPolicy/UpdateGlobalBGPConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InfraPolicyServer is the server API for InfraPolicy service.
type InfraPolicyServer interface {
	ActivePolicyUpdate(context.Context, *ActivePolicyUpdate) (*Reply, error)
	ActivePolicyRemove(context.Context, *ActivePolicyRemove) (*Reply, error)
	UpdateIPSet(context.Context, *IPSetUpdate) (*Reply, error)
	UpdateIPSetDelta(context.Context, *IPSetDeltaUpdate) (*Reply, error)
	RemoveIPSet(context.Context, *IPSetRemove) (*Reply, error)
	UpdateActiveProfile(context.Context, *ActiveProfileUpdate) (*Reply, error)
	RemoveActiveProfile(context.Context, *ActiveProfileRemove) (*Reply, error)
	UpdateHostEndpoint(context.Context, *HostEndpointUpdate) (*Reply, error)
	RemoveHostEndpoint(context.Context, *HostEndpointRemove) (*Reply, error)
	UpdateLocalEndpoint(context.Context, *WorkloadEndpointUpdate) (*Reply, error)
	RemoveLocalEndpoint(context.Context, *WorkloadEndpointRemove) (*Reply, error)
	UpdateHostMetaData(context.Context, *HostMetadataUpdate) (*Reply, error)
	RemoveHostMetaData(context.Context, *HostMetadataRemove) (*Reply, error)
	UpdateServiceAccount(context.Context, *ServiceAccountUpdate) (*Reply, error)
	RemoveServiceAccount(context.Context, *ServiceAccountRemove) (*Reply, error)
	UpdateNamespace(context.Context, *NamespaceUpdate) (*Reply, error)
	RemoveNamespace(context.Context, *NamespaceRemove) (*Reply, error)
	UpdateRoute(context.Context, *RouteUpdate) (*Reply, error)
	RemoveRoute(context.Context, *RouteRemove) (*Reply, error)
	UpdateVXLANTunnelEndpoint(context.Context, *VXLANTunnelEndpointUpdate) (*Reply, error)
	RemoveVXLANTunnelEndpoint(context.Context, *VXLANTunnelEndpointRemove) (*Reply, error)
	UpdateWireguardEndpoint(context.Context, *WireguardEndpointUpdate) (*Reply, error)
	RemoveWireguardEndpoint(context.Context, *WireguardEndpointRemove) (*Reply, error)
	UpdateGlobalBGPConfig(context.Context, *GlobalBGPConfigUpdate) (*Reply, error)
}

// UnimplementedInfraPolicyServer can be embedded to have forward compatible implementations.
type UnimplementedInfraPolicyServer struct {
}

func (*UnimplementedInfraPolicyServer) ActivePolicyUpdate(ctx context.Context, req *ActivePolicyUpdate) (*Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ActivePolicyUpdate not implemented")
}
func (*UnimplementedInfraPolicyServer) ActivePolicyRemove(ctx context.Context, req *ActivePolicyRemove) (*Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ActivePolicyRemove not implemented")
}
func (*UnimplementedInfraPolicyServer) UpdateIPSet(ctx context.Context, req *IPSetUpdate) (*Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateIPSet not implemented")
}
func (*UnimplementedInfraPolicyServer) UpdateIPSetDelta(ctx context.Context, req *IPSetDeltaUpdate) (*Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateIPSetDelta not implemented")
}
func (*UnimplementedInfraPolicyServer) RemoveIPSet(ctx context.Context, req *IPSetRemove) (*Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveIPSet not implemented")
}
func (*UnimplementedInfraPolicyServer) UpdateActiveProfile(ctx context.Context, req *ActiveProfileUpdate) (*Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateActiveProfile not implemented")
}
func (*UnimplementedInfraPolicyServer) RemoveActiveProfile(ctx context.Context, req *ActiveProfileRemove) (*Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveActiveProfile not implemented")
}
func (*UnimplementedInfraPolicyServer) UpdateHostEndpoint(ctx context.Context, req *HostEndpointUpdate) (*Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateHostEndpoint not implemented")
}
func (*UnimplementedInfraPolicyServer) RemoveHostEndpoint(ctx context.Context, req *HostEndpointRemove) (*Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveHostEndpoint not implemented")
}
func (*UnimplementedInfraPolicyServer) UpdateLocalEndpoint(ctx context.Context, req *WorkloadEndpointUpdate) (*Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateLocalEndpoint not implemented")
}
func (*UnimplementedInfraPolicyServer) RemoveLocalEndpoint(ctx context.Context, req *WorkloadEndpointRemove) (*Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveLocalEndpoint not implemented")
}
func (*UnimplementedInfraPolicyServer) UpdateHostMetaData(ctx context.Context, req *HostMetadataUpdate) (*Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateHostMetaData not implemented")
}
func (*UnimplementedInfraPolicyServer) RemoveHostMetaData(ctx context.Context, req *HostMetadataRemove) (*Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveHostMetaData not implemented")
}
func (*UnimplementedInfraPolicyServer) UpdateServiceAccount(ctx context.Context, req *ServiceAccountUpdate) (*Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateServiceAccount not implemented")
}
func (*UnimplementedInfraPolicyServer) RemoveServiceAccount(ctx context.Context, req *ServiceAccountRemove) (*Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveServiceAccount not implemented")
}
func (*UnimplementedInfraPolicyServer) UpdateNamespace(ctx context.Context, req *NamespaceUpdate) (*Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateNamespace not implemented")
}
func (*UnimplementedInfraPolicyServer) RemoveNamespace(ctx context.Context, req *NamespaceRemove) (*Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveNamespace not implemented")
}
func (*UnimplementedInfraPolicyServer) UpdateRoute(ctx context.Context, req *RouteUpdate) (*Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateRoute not implemented")
}
func (*UnimplementedInfraPolicyServer) RemoveRoute(ctx context.Context, req *RouteRemove) (*Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveRoute not implemented")
}
func (*UnimplementedInfraPolicyServer) UpdateVXLANTunnelEndpoint(ctx context.Context, req *VXLANTunnelEndpointUpdate) (*Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateVXLANTunnelEndpoint not implemented")
}
func (*UnimplementedInfraPolicyServer) RemoveVXLANTunnelEndpoint(ctx context.Context, req *VXLANTunnelEndpointRemove) (*Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveVXLANTunnelEndpoint not implemented")
}
func (*UnimplementedInfraPolicyServer) UpdateWireguardEndpoint(ctx context.Context, req *WireguardEndpointUpdate) (*Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateWireguardEndpoint not implemented")
}
func (*UnimplementedInfraPolicyServer) RemoveWireguardEndpoint(ctx context.Context, req *WireguardEndpointRemove) (*Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveWireguardEndpoint not implemented")
}
func (*UnimplementedInfraPolicyServer) UpdateGlobalBGPConfig(ctx context.Context, req *GlobalBGPConfigUpdate) (*Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateGlobalBGPConfig not implemented")
}

func RegisterInfraPolicyServer(s *grpc.Server, srv InfraPolicyServer) {
	s.RegisterService(&_InfraPolicy_serviceDesc, srv)
}

func _InfraPolicy_ActivePolicyUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ActivePolicyUpdate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfraPolicyServer).ActivePolicyUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/infra.InfraPolicy/ActivePolicyUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfraPolicyServer).ActivePolicyUpdate(ctx, req.(*ActivePolicyUpdate))
	}
	return interceptor(ctx, in, info, handler)
}

func _InfraPolicy_ActivePolicyRemove_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ActivePolicyRemove)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfraPolicyServer).ActivePolicyRemove(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/infra.InfraPolicy/ActivePolicyRemove",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfraPolicyServer).ActivePolicyRemove(ctx, req.(*ActivePolicyRemove))
	}
	return interceptor(ctx, in, info, handler)
}

func _InfraPolicy_UpdateIPSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IPSetUpdate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfraPolicyServer).UpdateIPSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/infra.InfraPolicy/UpdateIPSet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfraPolicyServer).UpdateIPSet(ctx, req.(*IPSetUpdate))
	}
	return interceptor(ctx, in, info, handler)
}

func _InfraPolicy_UpdateIPSetDelta_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IPSetDeltaUpdate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfraPolicyServer).UpdateIPSetDelta(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/infra.InfraPolicy/UpdateIPSetDelta",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfraPolicyServer).UpdateIPSetDelta(ctx, req.(*IPSetDeltaUpdate))
	}
	return interceptor(ctx, in, info, handler)
}

func _InfraPolicy_RemoveIPSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IPSetRemove)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfraPolicyServer).RemoveIPSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/infra.InfraPolicy/RemoveIPSet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfraPolicyServer).RemoveIPSet(ctx, req.(*IPSetRemove))
	}
	return interceptor(ctx, in, info, handler)
}

func _InfraPolicy_UpdateActiveProfile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ActiveProfileUpdate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfraPolicyServer).UpdateActiveProfile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/infra.InfraPolicy/UpdateActiveProfile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfraPolicyServer).UpdateActiveProfile(ctx, req.(*ActiveProfileUpdate))
	}
	return interceptor(ctx, in, info, handler)
}

func _InfraPolicy_RemoveActiveProfile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ActiveProfileRemove)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfraPolicyServer).RemoveActiveProfile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/infra.InfraPolicy/RemoveActiveProfile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfraPolicyServer).RemoveActiveProfile(ctx, req.(*ActiveProfileRemove))
	}
	return interceptor(ctx, in, info, handler)
}

func _InfraPolicy_UpdateHostEndpoint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HostEndpointUpdate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfraPolicyServer).UpdateHostEndpoint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/infra.InfraPolicy/UpdateHostEndpoint",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfraPolicyServer).UpdateHostEndpoint(ctx, req.(*HostEndpointUpdate))
	}
	return interceptor(ctx, in, info, handler)
}

func _InfraPolicy_RemoveHostEndpoint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HostEndpointRemove)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfraPolicyServer).RemoveHostEndpoint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/infra.InfraPolicy/RemoveHostEndpoint",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfraPolicyServer).RemoveHostEndpoint(ctx, req.(*HostEndpointRemove))
	}
	return interceptor(ctx, in, info, handler)
}

func _InfraPolicy_UpdateLocalEndpoint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WorkloadEndpointUpdate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfraPolicyServer).UpdateLocalEndpoint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/infra.InfraPolicy/UpdateLocalEndpoint",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfraPolicyServer).UpdateLocalEndpoint(ctx, req.(*WorkloadEndpointUpdate))
	}
	return interceptor(ctx, in, info, handler)
}

func _InfraPolicy_RemoveLocalEndpoint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WorkloadEndpointRemove)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfraPolicyServer).RemoveLocalEndpoint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/infra.InfraPolicy/RemoveLocalEndpoint",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfraPolicyServer).RemoveLocalEndpoint(ctx, req.(*WorkloadEndpointRemove))
	}
	return interceptor(ctx, in, info, handler)
}

func _InfraPolicy_UpdateHostMetaData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HostMetadataUpdate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfraPolicyServer).UpdateHostMetaData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/infra.InfraPolicy/UpdateHostMetaData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfraPolicyServer).UpdateHostMetaData(ctx, req.(*HostMetadataUpdate))
	}
	return interceptor(ctx, in, info, handler)
}

func _InfraPolicy_RemoveHostMetaData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HostMetadataRemove)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfraPolicyServer).RemoveHostMetaData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/infra.InfraPolicy/RemoveHostMetaData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfraPolicyServer).RemoveHostMetaData(ctx, req.(*HostMetadataRemove))
	}
	return interceptor(ctx, in, info, handler)
}

func _InfraPolicy_UpdateServiceAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ServiceAccountUpdate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfraPolicyServer).UpdateServiceAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/infra.InfraPolicy/UpdateServiceAccount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfraPolicyServer).UpdateServiceAccount(ctx, req.(*ServiceAccountUpdate))
	}
	return interceptor(ctx, in, info, handler)
}

func _InfraPolicy_RemoveServiceAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ServiceAccountRemove)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfraPolicyServer).RemoveServiceAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/infra.InfraPolicy/RemoveServiceAccount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfraPolicyServer).RemoveServiceAccount(ctx, req.(*ServiceAccountRemove))
	}
	return interceptor(ctx, in, info, handler)
}

func _InfraPolicy_UpdateNamespace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NamespaceUpdate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfraPolicyServer).UpdateNamespace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/infra.InfraPolicy/UpdateNamespace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfraPolicyServer).UpdateNamespace(ctx, req.(*NamespaceUpdate))
	}
	return interceptor(ctx, in, info, handler)
}

func _InfraPolicy_RemoveNamespace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NamespaceRemove)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfraPolicyServer).RemoveNamespace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/infra.InfraPolicy/RemoveNamespace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfraPolicyServer).RemoveNamespace(ctx, req.(*NamespaceRemove))
	}
	return interceptor(ctx, in, info, handler)
}

func _InfraPolicy_UpdateRoute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RouteUpdate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfraPolicyServer).UpdateRoute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/infra.InfraPolicy/UpdateRoute",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfraPolicyServer).UpdateRoute(ctx, req.(*RouteUpdate))
	}
	return interceptor(ctx, in, info, handler)
}

func _InfraPolicy_RemoveRoute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RouteRemove)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfraPolicyServer).RemoveRoute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/infra.InfraPolicy/RemoveRoute",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfraPolicyServer).RemoveRoute(ctx, req.(*RouteRemove))
	}
	return interceptor(ctx, in, info, handler)
}

func _InfraPolicy_UpdateVXLANTunnelEndpoint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VXLANTunnelEndpointUpdate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfraPolicyServer).UpdateVXLANTunnelEndpoint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/infra.InfraPolicy/UpdateVXLANTunnelEndpoint",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfraPolicyServer).UpdateVXLANTunnelEndpoint(ctx, req.(*VXLANTunnelEndpointUpdate))
	}
	return interceptor(ctx, in, info, handler)
}

func _InfraPolicy_RemoveVXLANTunnelEndpoint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VXLANTunnelEndpointRemove)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfraPolicyServer).RemoveVXLANTunnelEndpoint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/infra.InfraPolicy/RemoveVXLANTunnelEndpoint",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfraPolicyServer).RemoveVXLANTunnelEndpoint(ctx, req.(*VXLANTunnelEndpointRemove))
	}
	return interceptor(ctx, in, info, handler)
}

func _InfraPolicy_UpdateWireguardEndpoint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WireguardEndpointUpdate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfraPolicyServer).UpdateWireguardEndpoint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/infra.InfraPolicy/UpdateWireguardEndpoint",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfraPolicyServer).UpdateWireguardEndpoint(ctx, req.(*WireguardEndpointUpdate))
	}
	return interceptor(ctx, in, info, handler)
}

func _InfraPolicy_RemoveWireguardEndpoint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WireguardEndpointRemove)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfraPolicyServer).RemoveWireguardEndpoint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/infra.InfraPolicy/RemoveWireguardEndpoint",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfraPolicyServer).RemoveWireguardEndpoint(ctx, req.(*WireguardEndpointRemove))
	}
	return interceptor(ctx, in, info, handler)
}

func _InfraPolicy_UpdateGlobalBGPConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GlobalBGPConfigUpdate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfraPolicyServer).UpdateGlobalBGPConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/infra.InfraPolicy/UpdateGlobalBGPConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfraPolicyServer).UpdateGlobalBGPConfig(ctx, req.(*GlobalBGPConfigUpdate))
	}
	return interceptor(ctx, in, info, handler)
}

var _InfraPolicy_serviceDesc = grpc.ServiceDesc{
	ServiceName: "infra.InfraPolicy",
	HandlerType: (*InfraPolicyServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ActivePolicyUpdate",
			Handler:    _InfraPolicy_ActivePolicyUpdate_Handler,
		},
		{
			MethodName: "ActivePolicyRemove",
			Handler:    _InfraPolicy_ActivePolicyRemove_Handler,
		},
		{
			MethodName: "UpdateIPSet",
			Handler:    _InfraPolicy_UpdateIPSet_Handler,
		},
		{
			MethodName: "UpdateIPSetDelta",
			Handler:    _InfraPolicy_UpdateIPSetDelta_Handler,
		},
		{
			MethodName: "RemoveIPSet",
			Handler:    _InfraPolicy_RemoveIPSet_Handler,
		},
		{
			MethodName: "UpdateActiveProfile",
			Handler:    _InfraPolicy_UpdateActiveProfile_Handler,
		},
		{
			MethodName: "RemoveActiveProfile",
			Handler:    _InfraPolicy_RemoveActiveProfile_Handler,
		},
		{
			MethodName: "UpdateHostEndpoint",
			Handler:    _InfraPolicy_UpdateHostEndpoint_Handler,
		},
		{
			MethodName: "RemoveHostEndpoint",
			Handler:    _InfraPolicy_RemoveHostEndpoint_Handler,
		},
		{
			MethodName: "UpdateLocalEndpoint",
			Handler:    _InfraPolicy_UpdateLocalEndpoint_Handler,
		},
		{
			MethodName: "RemoveLocalEndpoint",
			Handler:    _InfraPolicy_RemoveLocalEndpoint_Handler,
		},
		{
			MethodName: "UpdateHostMetaData",
			Handler:    _InfraPolicy_UpdateHostMetaData_Handler,
		},
		{
			MethodName: "RemoveHostMetaData",
			Handler:    _InfraPolicy_RemoveHostMetaData_Handler,
		},
		{
			MethodName: "UpdateServiceAccount",
			Handler:    _InfraPolicy_UpdateServiceAccount_Handler,
		},
		{
			MethodName: "RemoveServiceAccount",
			Handler:    _InfraPolicy_RemoveServiceAccount_Handler,
		},
		{
			MethodName: "UpdateNamespace",
			Handler:    _InfraPolicy_UpdateNamespace_Handler,
		},
		{
			MethodName: "RemoveNamespace",
			Handler:    _InfraPolicy_RemoveNamespace_Handler,
		},
		{
			MethodName: "UpdateRoute",
			Handler:    _InfraPolicy_UpdateRoute_Handler,
		},
		{
			MethodName: "RemoveRoute",
			Handler:    _InfraPolicy_RemoveRoute_Handler,
		},
		{
			MethodName: "UpdateVXLANTunnelEndpoint",
			Handler:    _InfraPolicy_UpdateVXLANTunnelEndpoint_Handler,
		},
		{
			MethodName: "RemoveVXLANTunnelEndpoint",
			Handler:    _InfraPolicy_RemoveVXLANTunnelEndpoint_Handler,
		},
		{
			MethodName: "UpdateWireguardEndpoint",
			Handler:    _InfraPolicy_UpdateWireguardEndpoint_Handler,
		},
		{
			MethodName: "RemoveWireguardEndpoint",
			Handler:    _InfraPolicy_RemoveWireguardEndpoint_Handler,
		},
		{
			MethodName: "UpdateGlobalBGPConfig",
			Handler:    _InfraPolicy_UpdateGlobalBGPConfig_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "infra.proto",
}

func (m *Reply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Reply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Reply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintInfra(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x12
	}
	if m.Successful {
		i--
		if m.Successful {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NatEndpoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatEndpoint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NatEndpoint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Port != 0 {
		i = encodeVarintInfra(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Ipv4Addr) > 0 {
		i -= len(m.Ipv4Addr)
		copy(dAtA[i:], m.Ipv4Addr)
		i = encodeVarintInfra(dAtA, i, uint64(len(m.Ipv4Addr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NatEndpointTuple) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatEndpointTuple) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NatEndpointTuple) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SrcEp != nil {
		{
			size, err := m.SrcEp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInfra(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.DstEp != nil {
		{
			size, err := m.DstEp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInfra(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NatTranslation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatTranslation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NatTranslation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Backends) > 0 {
		for iNdEx := len(m.Backends) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Backends[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintInfra(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.IsRealIp {
		i--
		if m.IsRealIp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Proto) > 0 {
		i -= len(m.Proto)
		copy(dAtA[i:], m.Proto)
		i = encodeVarintInfra(dAtA, i, uint64(len(m.Proto)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Endpoint != nil {
		{
			size, err := m.Endpoint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInfra(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *SetSnatAddressRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetSnatAddressRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetSnatAddressRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SnatIpv6) > 0 {
		i -= len(m.SnatIpv6)
		copy(dAtA[i:], m.SnatIpv6)
		i = encodeVarintInfra(dAtA, i, uint64(len(m.SnatIpv6)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SnatIpv4) > 0 {
		i -= len(m.SnatIpv4)
		copy(dAtA[i:], m.SnatIpv4)
		i = encodeVarintInfra(dAtA, i, uint64(len(m.SnatIpv4)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AddDelSnatPrefixRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddDelSnatPrefixRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddDelSnatPrefixRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Prefix) > 0 {
		i -= len(m.Prefix)
		copy(dAtA[i:], m.Prefix)
		i = encodeVarintInfra(dAtA, i, uint64(len(m.Prefix)))
		i--
		dAtA[i] = 0x12
	}
	if m.IsAdd {
		i--
		if m.IsAdd {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CreateNetworkRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateNetworkRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateNetworkRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.MacAddr) > 0 {
		i -= len(m.MacAddr)
		copy(dAtA[i:], m.MacAddr)
		i = encodeVarintInfra(dAtA, i, uint64(len(m.MacAddr)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.HostIfName) > 0 {
		i -= len(m.HostIfName)
		copy(dAtA[i:], m.HostIfName)
		i = encodeVarintInfra(dAtA, i, uint64(len(m.HostIfName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DesiredHostInterfaceName) > 0 {
		i -= len(m.DesiredHostInterfaceName)
		copy(dAtA[i:], m.DesiredHostInterfaceName)
		i = encodeVarintInfra(dAtA, i, uint64(len(m.DesiredHostInterfaceName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContainerIps) > 0 {
		for iNdEx := len(m.ContainerIps) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ContainerIps[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintInfra(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DeleteNetworkRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteNetworkRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteNetworkRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Ipv4Addr) > 0 {
		i -= len(m.Ipv4Addr)
		copy(dAtA[i:], m.Ipv4Addr)
		i = encodeVarintInfra(dAtA, i, uint64(len(m.Ipv4Addr)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.MacAddr) > 0 {
		i -= len(m.MacAddr)
		copy(dAtA[i:], m.MacAddr)
		i = encodeVarintInfra(dAtA, i, uint64(len(m.MacAddr)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.HostIfName) > 0 {
		i -= len(m.HostIfName)
		copy(dAtA[i:], m.HostIfName)
		i = encodeVarintInfra(dAtA, i, uint64(len(m.HostIfName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.InterfaceName) > 0 {
		i -= len(m.InterfaceName)
		copy(dAtA[i:], m.InterfaceName)
		i = encodeVarintInfra(dAtA, i, uint64(len(m.InterfaceName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SetupHostInterfaceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetupHostInterfaceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetupHostInterfaceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.MacAddr) > 0 {
		i -= len(m.MacAddr)
		copy(dAtA[i:], m.MacAddr)
		i = encodeVarintInfra(dAtA, i, uint64(len(m.MacAddr)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Ipv4Addr) > 0 {
		i -= len(m.Ipv4Addr)
		copy(dAtA[i:], m.Ipv4Addr)
		i = encodeVarintInfra(dAtA, i, uint64(len(m.Ipv4Addr)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.IfName) > 0 {
		i -= len(m.IfName)
		copy(dAtA[i:], m.IfName)
		i = encodeVarintInfra(dAtA, i, uint64(len(m.IfName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IPConfiguration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPConfiguration) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IPConfiguration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Gateway) > 0 {
		i -= len(m.Gateway)
		copy(dAtA[i:], m.Gateway)
		i = encodeVarintInfra(dAtA, i, uint64(len(m.Gateway)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintInfra(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InfraAddReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InfraAddReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InfraAddReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.HostInterfaceName) > 0 {
		i -= len(m.HostInterfaceName)
		copy(dAtA[i:], m.HostInterfaceName)
		i = encodeVarintInfra(dAtA, i, uint64(len(m.HostInterfaceName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintInfra(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x12
	}
	if m.Successful {
		i--
		if m.Successful {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintInfra(dAtA []byte, offset int, v uint64) int {
	offset -= sovInfra(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Reply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Successful {
		n += 2
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovInfra(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NatEndpoint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Ipv4Addr)
	if l > 0 {
		n += 1 + l + sovInfra(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovInfra(uint64(m.Port))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NatEndpointTuple) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DstEp != nil {
		l = m.DstEp.Size()
		n += 1 + l + sovInfra(uint64(l))
	}
	if m.SrcEp != nil {
		l = m.SrcEp.Size()
		n += 1 + l + sovInfra(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NatTranslation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Endpoint != nil {
		l = m.Endpoint.Size()
		n += 1 + l + sovInfra(uint64(l))
	}
	l = len(m.Proto)
	if l > 0 {
		n += 1 + l + sovInfra(uint64(l))
	}
	if m.IsRealIp {
		n += 2
	}
	if len(m.Backends) > 0 {
		for _, e := range m.Backends {
			l = e.Size()
			n += 1 + l + sovInfra(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetSnatAddressRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SnatIpv4)
	if l > 0 {
		n += 1 + l + sovInfra(uint64(l))
	}
	l = len(m.SnatIpv6)
	if l > 0 {
		n += 1 + l + sovInfra(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddDelSnatPrefixRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsAdd {
		n += 2
	}
	l = len(m.Prefix)
	if l > 0 {
		n += 1 + l + sovInfra(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateNetworkRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ContainerIps) > 0 {
		for _, e := range m.ContainerIps {
			l = e.Size()
			n += 1 + l + sovInfra(uint64(l))
		}
	}
	l = len(m.DesiredHostInterfaceName)
	if l > 0 {
		n += 1 + l + sovInfra(uint64(l))
	}
	l = len(m.HostIfName)
	if l > 0 {
		n += 1 + l + sovInfra(uint64(l))
	}
	l = len(m.MacAddr)
	if l > 0 {
		n += 1 + l + sovInfra(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteNetworkRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.InterfaceName)
	if l > 0 {
		n += 1 + l + sovInfra(uint64(l))
	}
	l = len(m.HostIfName)
	if l > 0 {
		n += 1 + l + sovInfra(uint64(l))
	}
	l = len(m.MacAddr)
	if l > 0 {
		n += 1 + l + sovInfra(uint64(l))
	}
	l = len(m.Ipv4Addr)
	if l > 0 {
		n += 1 + l + sovInfra(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetupHostInterfaceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.IfName)
	if l > 0 {
		n += 1 + l + sovInfra(uint64(l))
	}
	l = len(m.Ipv4Addr)
	if l > 0 {
		n += 1 + l + sovInfra(uint64(l))
	}
	l = len(m.MacAddr)
	if l > 0 {
		n += 1 + l + sovInfra(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IPConfiguration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovInfra(uint64(l))
	}
	l = len(m.Gateway)
	if l > 0 {
		n += 1 + l + sovInfra(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InfraAddReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Successful {
		n += 2
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovInfra(uint64(l))
	}
	l = len(m.HostInterfaceName)
	if l > 0 {
		n += 1 + l + sovInfra(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovInfra(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozInfra(x uint64) (n int) {
	return sovInfra(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Reply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInfra
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Reply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Reply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Successful", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfra
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Successful = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfra
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInfra
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInfra
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInfra(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInfra
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatEndpoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInfra
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatEndpoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatEndpoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv4Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfra
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInfra
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInfra
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ipv4Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfra
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInfra(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInfra
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatEndpointTuple) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInfra
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatEndpointTuple: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatEndpointTuple: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstEp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfra
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInfra
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInfra
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DstEp == nil {
				m.DstEp = &NatEndpoint{}
			}
			if err := m.DstEp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcEp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfra
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInfra
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInfra
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SrcEp == nil {
				m.SrcEp = &NatEndpoint{}
			}
			if err := m.SrcEp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInfra(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInfra
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatTranslation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInfra
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatTranslation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatTranslation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfra
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInfra
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInfra
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Endpoint == nil {
				m.Endpoint = &NatEndpoint{}
			}
			if err := m.Endpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proto", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfra
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInfra
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInfra
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proto = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRealIp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfra
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRealIp = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Backends", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfra
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInfra
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInfra
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Backends = append(m.Backends, &NatEndpointTuple{})
			if err := m.Backends[len(m.Backends)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInfra(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInfra
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetSnatAddressRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInfra
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetSnatAddressRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetSnatAddressRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnatIpv4", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfra
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInfra
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInfra
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SnatIpv4 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnatIpv6", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfra
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInfra
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInfra
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SnatIpv6 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInfra(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInfra
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddDelSnatPrefixRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInfra
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddDelSnatPrefixRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddDelSnatPrefixRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAdd", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfra
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsAdd = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfra
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInfra
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInfra
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInfra(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInfra
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateNetworkRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInfra
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateNetworkRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateNetworkRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerIps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfra
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInfra
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInfra
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerIps = append(m.ContainerIps, &IPConfiguration{})
			if err := m.ContainerIps[len(m.ContainerIps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesiredHostInterfaceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfra
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInfra
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInfra
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DesiredHostInterfaceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostIfName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfra
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInfra
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInfra
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostIfName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfra
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInfra
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInfra
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MacAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInfra(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInfra
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteNetworkRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInfra
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteNetworkRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteNetworkRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfra
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInfra
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInfra
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InterfaceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostIfName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfra
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInfra
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInfra
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostIfName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfra
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInfra
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInfra
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MacAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv4Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfra
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInfra
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInfra
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ipv4Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInfra(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInfra
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetupHostInterfaceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInfra
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetupHostInterfaceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetupHostInterfaceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfra
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInfra
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInfra
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IfName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv4Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfra
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInfra
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInfra
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ipv4Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfra
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInfra
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInfra
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MacAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInfra(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInfra
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPConfiguration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInfra
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPConfiguration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPConfiguration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfra
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInfra
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInfra
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gateway", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfra
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInfra
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInfra
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gateway = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInfra(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInfra
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InfraAddReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInfra
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InfraAddReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InfraAddReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Successful", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfra
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Successful = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfra
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInfra
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInfra
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostInterfaceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfra
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInfra
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInfra
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostInterfaceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInfra(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInfra
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipInfra(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowInfra
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowInfra
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowInfra
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthInfra
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupInfra
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthInfra
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthInfra        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowInfra          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupInfra = fmt.Errorf("proto: unexpected end of group")
)
